"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@prisma+instrumentation@7.2.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@prisma+instrumentation@7.2.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@prisma+instrumentation@7.2.0_@opentelemetry+api@1.9.0/node_modules/@prisma/instrumentation/dist/index.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@prisma+instrumentation@7.2.0_@opentelemetry+api@1.9.0/node_modules/@prisma/instrumentation/dist/index.js ***!
  \**************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  PrismaInstrumentation: () => PrismaInstrumentation,\n  registerInstrumentations: () => import_instrumentation2.registerInstrumentations\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/PrismaInstrumentation.ts\nvar import_api2 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nvar import_instrumentation = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.207.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\n\n// ../instrumentation-contract/dist/index.mjs\nvar package_default = {\n  name: \"@prisma/instrumentation-contract\",\n  version: \"7.2.0\",\n  description: \"Shared types and utilities for Prisma instrumentation\",\n  main: \"dist/index.js\",\n  module: \"dist/index.mjs\",\n  types: \"dist/index.d.ts\",\n  exports: {\n    \".\": {\n      require: {\n        types: \"./dist/index.d.ts\",\n        default: \"./dist/index.js\"\n      },\n      import: {\n        types: \"./dist/index.d.mts\",\n        default: \"./dist/index.mjs\"\n      }\n    }\n  },\n  license: \"Apache-2.0\",\n  homepage: \"https://www.prisma.io\",\n  repository: {\n    type: \"git\",\n    url: \"https://github.com/prisma/prisma.git\",\n    directory: \"packages/instrumentation-contract\"\n  },\n  bugs: \"https://github.com/prisma/prisma/issues\",\n  scripts: {\n    dev: \"DEV=true tsx helpers/build.ts\",\n    build: \"tsx helpers/build.ts\",\n    prepublishOnly: \"pnpm run build\",\n    test: \"vitest run\"\n  },\n  files: [\n    \"dist\"\n  ],\n  sideEffects: false,\n  devDependencies: {\n    \"@opentelemetry/api\": \"1.9.0\"\n  },\n  peerDependencies: {\n    \"@opentelemetry/api\": \"^1.8\"\n  }\n};\nvar majorVersion = package_default.version.split(\".\")[0];\nvar GLOBAL_INSTRUMENTATION_KEY = \"PRISMA_INSTRUMENTATION\";\nvar GLOBAL_VERSIONED_INSTRUMENTATION_KEY = `V${majorVersion}_PRISMA_INSTRUMENTATION`;\nvar globalThisWithPrismaInstrumentation = globalThis;\nfunction getGlobalTracingHelper() {\n  const versionedGlobal = globalThisWithPrismaInstrumentation[GLOBAL_VERSIONED_INSTRUMENTATION_KEY];\n  if (versionedGlobal?.helper) {\n    return versionedGlobal.helper;\n  }\n  const fallbackGlobal = globalThisWithPrismaInstrumentation[GLOBAL_INSTRUMENTATION_KEY];\n  return fallbackGlobal?.helper;\n}\nfunction setGlobalTracingHelper(helper) {\n  const globalValue = { helper };\n  globalThisWithPrismaInstrumentation[GLOBAL_VERSIONED_INSTRUMENTATION_KEY] = globalValue;\n  globalThisWithPrismaInstrumentation[GLOBAL_INSTRUMENTATION_KEY] = globalValue;\n}\nfunction clearGlobalTracingHelper() {\n  delete globalThisWithPrismaInstrumentation[GLOBAL_VERSIONED_INSTRUMENTATION_KEY];\n  delete globalThisWithPrismaInstrumentation[GLOBAL_INSTRUMENTATION_KEY];\n}\n\n// src/ActiveTracingHelper.ts\nvar import_api = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nvar showAllTraces = process.env.PRISMA_SHOW_ALL_TRACES === \"true\";\nvar nonSampledTraceParent = `00-10-10-00`;\nfunction engineSpanKindToOtelSpanKind(engineSpanKind) {\n  switch (engineSpanKind) {\n    case \"client\":\n      return import_api.SpanKind.CLIENT;\n    case \"internal\":\n    default:\n      return import_api.SpanKind.INTERNAL;\n  }\n}\nvar ActiveTracingHelper = class {\n  tracerProvider;\n  ignoreSpanTypes;\n  constructor({ tracerProvider, ignoreSpanTypes }) {\n    this.tracerProvider = tracerProvider;\n    this.ignoreSpanTypes = ignoreSpanTypes;\n  }\n  isEnabled() {\n    return true;\n  }\n  getTraceParent(context) {\n    const span = import_api.trace.getSpanContext(context ?? import_api.context.active());\n    if (span) {\n      return `00-${span.traceId}-${span.spanId}-0${span.traceFlags}`;\n    }\n    return nonSampledTraceParent;\n  }\n  dispatchEngineSpans(spans) {\n    const tracer = this.tracerProvider.getTracer(\"prisma\");\n    const linkIds = /* @__PURE__ */ new Map();\n    const roots = spans.filter((span) => span.parentId === null);\n    for (const root of roots) {\n      dispatchEngineSpan(tracer, root, spans, linkIds, this.ignoreSpanTypes);\n    }\n  }\n  getActiveContext() {\n    return import_api.context.active();\n  }\n  runInChildSpan(options, callback) {\n    if (typeof options === \"string\") {\n      options = { name: options };\n    }\n    if (options.internal && !showAllTraces) {\n      return callback();\n    }\n    const tracer = this.tracerProvider.getTracer(\"prisma\");\n    const context = options.context ?? this.getActiveContext();\n    const name = `prisma:client:${options.name}`;\n    if (shouldIgnoreSpan(name, this.ignoreSpanTypes)) {\n      return callback();\n    }\n    if (options.active === false) {\n      const span = tracer.startSpan(name, options, context);\n      return endSpan(span, callback(span, context));\n    }\n    return tracer.startActiveSpan(name, options, (span) => endSpan(span, callback(span, context)));\n  }\n};\nfunction dispatchEngineSpan(tracer, engineSpan, allSpans, linkIds, ignoreSpanTypes) {\n  if (shouldIgnoreSpan(engineSpan.name, ignoreSpanTypes)) return;\n  const spanOptions = {\n    attributes: engineSpan.attributes,\n    kind: engineSpanKindToOtelSpanKind(engineSpan.kind),\n    startTime: engineSpan.startTime\n  };\n  tracer.startActiveSpan(engineSpan.name, spanOptions, (span) => {\n    linkIds.set(engineSpan.id, span.spanContext().spanId);\n    if (engineSpan.links) {\n      span.addLinks(\n        engineSpan.links.flatMap((link) => {\n          const linkedId = linkIds.get(link);\n          if (!linkedId) {\n            return [];\n          }\n          return {\n            context: {\n              spanId: linkedId,\n              traceId: span.spanContext().traceId,\n              traceFlags: span.spanContext().traceFlags\n            }\n          };\n        })\n      );\n    }\n    const children = allSpans.filter((s) => s.parentId === engineSpan.id);\n    for (const child of children) {\n      dispatchEngineSpan(tracer, child, allSpans, linkIds, ignoreSpanTypes);\n    }\n    span.end(engineSpan.endTime);\n  });\n}\nfunction endSpan(span, result) {\n  if (isPromiseLike(result)) {\n    return result.then(\n      (value) => {\n        span.end();\n        return value;\n      },\n      (reason) => {\n        span.end();\n        throw reason;\n      }\n    );\n  }\n  span.end();\n  return result;\n}\nfunction isPromiseLike(value) {\n  return value != null && typeof value[\"then\"] === \"function\";\n}\nfunction shouldIgnoreSpan(spanName, ignoreSpanTypes) {\n  return ignoreSpanTypes.some(\n    (pattern) => typeof pattern === \"string\" ? pattern === spanName : pattern.test(spanName)\n  );\n}\n\n// package.json\nvar package_default2 = {\n  name: \"@prisma/instrumentation\",\n  version: \"7.2.0\",\n  description: \"OpenTelemetry compliant instrumentation for Prisma Client\",\n  main: \"dist/index.js\",\n  module: \"dist/index.mjs\",\n  types: \"dist/index.d.ts\",\n  exports: {\n    \".\": {\n      require: {\n        types: \"./dist/index.d.ts\",\n        default: \"./dist/index.js\"\n      },\n      import: {\n        types: \"./dist/index.d.ts\",\n        default: \"./dist/index.mjs\"\n      }\n    }\n  },\n  license: \"Apache-2.0\",\n  homepage: \"https://www.prisma.io\",\n  repository: {\n    type: \"git\",\n    url: \"https://github.com/prisma/prisma.git\",\n    directory: \"packages/instrumentation\"\n  },\n  bugs: \"https://github.com/prisma/prisma/issues\",\n  devDependencies: {\n    \"@opentelemetry/api\": \"1.9.0\",\n    \"@prisma/instrumentation-contract\": \"workspace:*\",\n    \"@types/node\": \"~20.19.24\",\n    typescript: \"5.4.5\"\n  },\n  dependencies: {\n    \"@opentelemetry/instrumentation\": \"^0.207.0\"\n  },\n  peerDependencies: {\n    \"@opentelemetry/api\": \"^1.8\"\n  },\n  files: [\n    \"dist\"\n  ],\n  keywords: [\n    \"prisma\",\n    \"instrumentation\",\n    \"opentelemetry\",\n    \"otel\"\n  ],\n  scripts: {\n    dev: \"DEV=true tsx helpers/build.ts\",\n    build: \"tsx helpers/build.ts\",\n    prepublishOnly: \"pnpm run build\",\n    test: \"vitest run\"\n  },\n  sideEffects: false\n};\n\n// src/constants.ts\nvar VERSION = package_default2.version;\nvar NAME = package_default2.name;\nvar MODULE_NAME = \"@prisma/client\";\n\n// src/PrismaInstrumentation.ts\nvar PrismaInstrumentation = class extends import_instrumentation.InstrumentationBase {\n  tracerProvider;\n  constructor(config = {}) {\n    super(NAME, VERSION, config);\n  }\n  setTracerProvider(tracerProvider) {\n    this.tracerProvider = tracerProvider;\n  }\n  init() {\n    const module2 = new import_instrumentation.InstrumentationNodeModuleDefinition(MODULE_NAME, [VERSION]);\n    return [module2];\n  }\n  enable() {\n    const config = this._config;\n    setGlobalTracingHelper(\n      new ActiveTracingHelper({\n        tracerProvider: this.tracerProvider ?? import_api2.trace.getTracerProvider(),\n        ignoreSpanTypes: config.ignoreSpanTypes ?? []\n      })\n    );\n  }\n  disable() {\n    clearGlobalTracingHelper();\n  }\n  isEnabled() {\n    return getGlobalTracingHelper() !== void 0;\n  }\n};\n\n// src/index.ts\nvar import_instrumentation2 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.207.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByaXNtYStpbnN0cnVtZW50YXRpb25ANy4yLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9AcHJpc21hL2luc3RydW1lbnRhdGlvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxrSUFBb0I7QUFDOUMsNkJBQTZCLG1CQUFPLENBQUMsaU1BQWdDOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0lBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsWUFBWSxJQUFJLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGlNQUFnQztBQUN0RTtBQUNBLE1BQU0sQ0FHTCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlaWluZGlhcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJpc21hK2luc3RydW1lbnRhdGlvbkA3LjIuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BwcmlzbWEvaW5zdHJ1bWVudGF0aW9uL2Rpc3QvaW5kZXguanM/NzA4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluZGV4X2V4cG9ydHMsIHtcbiAgUHJpc21hSW5zdHJ1bWVudGF0aW9uOiAoKSA9PiBQcmlzbWFJbnN0cnVtZW50YXRpb24sXG4gIHJlZ2lzdGVySW5zdHJ1bWVudGF0aW9uczogKCkgPT4gaW1wb3J0X2luc3RydW1lbnRhdGlvbjIucmVnaXN0ZXJJbnN0cnVtZW50YXRpb25zXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xuXG4vLyBzcmMvUHJpc21hSW5zdHJ1bWVudGF0aW9uLnRzXG52YXIgaW1wb3J0X2FwaTIgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xudmFyIGltcG9ydF9pbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuXG4vLyAuLi9pbnN0cnVtZW50YXRpb24tY29udHJhY3QvZGlzdC9pbmRleC5tanNcbnZhciBwYWNrYWdlX2RlZmF1bHQgPSB7XG4gIG5hbWU6IFwiQHByaXNtYS9pbnN0cnVtZW50YXRpb24tY29udHJhY3RcIixcbiAgdmVyc2lvbjogXCI3LjIuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJTaGFyZWQgdHlwZXMgYW5kIHV0aWxpdGllcyBmb3IgUHJpc21hIGluc3RydW1lbnRhdGlvblwiLFxuICBtYWluOiBcImRpc3QvaW5kZXguanNcIixcbiAgbW9kdWxlOiBcImRpc3QvaW5kZXgubWpzXCIsXG4gIHR5cGVzOiBcImRpc3QvaW5kZXguZC50c1wiLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHJlcXVpcmU6IHtcbiAgICAgICAgdHlwZXM6IFwiLi9kaXN0L2luZGV4LmQudHNcIixcbiAgICAgICAgZGVmYXVsdDogXCIuL2Rpc3QvaW5kZXguanNcIlxuICAgICAgfSxcbiAgICAgIGltcG9ydDoge1xuICAgICAgICB0eXBlczogXCIuL2Rpc3QvaW5kZXguZC5tdHNcIixcbiAgICAgICAgZGVmYXVsdDogXCIuL2Rpc3QvaW5kZXgubWpzXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGxpY2Vuc2U6IFwiQXBhY2hlLTIuMFwiLFxuICBob21lcGFnZTogXCJodHRwczovL3d3dy5wcmlzbWEuaW9cIixcbiAgcmVwb3NpdG9yeToge1xuICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hLmdpdFwiLFxuICAgIGRpcmVjdG9yeTogXCJwYWNrYWdlcy9pbnN0cnVtZW50YXRpb24tY29udHJhY3RcIlxuICB9LFxuICBidWdzOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc1wiLFxuICBzY3JpcHRzOiB7XG4gICAgZGV2OiBcIkRFVj10cnVlIHRzeCBoZWxwZXJzL2J1aWxkLnRzXCIsXG4gICAgYnVpbGQ6IFwidHN4IGhlbHBlcnMvYnVpbGQudHNcIixcbiAgICBwcmVwdWJsaXNoT25seTogXCJwbnBtIHJ1biBidWlsZFwiLFxuICAgIHRlc3Q6IFwidml0ZXN0IHJ1blwiXG4gIH0sXG4gIGZpbGVzOiBbXG4gICAgXCJkaXN0XCJcbiAgXSxcbiAgc2lkZUVmZmVjdHM6IGZhbHNlLFxuICBkZXZEZXBlbmRlbmNpZXM6IHtcbiAgICBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiOiBcIjEuOS4wXCJcbiAgfSxcbiAgcGVlckRlcGVuZGVuY2llczoge1xuICAgIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI6IFwiXjEuOFwiXG4gIH1cbn07XG52YXIgbWFqb3JWZXJzaW9uID0gcGFja2FnZV9kZWZhdWx0LnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdO1xudmFyIEdMT0JBTF9JTlNUUlVNRU5UQVRJT05fS0VZID0gXCJQUklTTUFfSU5TVFJVTUVOVEFUSU9OXCI7XG52YXIgR0xPQkFMX1ZFUlNJT05FRF9JTlNUUlVNRU5UQVRJT05fS0VZID0gYFYke21ham9yVmVyc2lvbn1fUFJJU01BX0lOU1RSVU1FTlRBVElPTmA7XG52YXIgZ2xvYmFsVGhpc1dpdGhQcmlzbWFJbnN0cnVtZW50YXRpb24gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gZ2V0R2xvYmFsVHJhY2luZ0hlbHBlcigpIHtcbiAgY29uc3QgdmVyc2lvbmVkR2xvYmFsID0gZ2xvYmFsVGhpc1dpdGhQcmlzbWFJbnN0cnVtZW50YXRpb25bR0xPQkFMX1ZFUlNJT05FRF9JTlNUUlVNRU5UQVRJT05fS0VZXTtcbiAgaWYgKHZlcnNpb25lZEdsb2JhbD8uaGVscGVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25lZEdsb2JhbC5oZWxwZXI7XG4gIH1cbiAgY29uc3QgZmFsbGJhY2tHbG9iYWwgPSBnbG9iYWxUaGlzV2l0aFByaXNtYUluc3RydW1lbnRhdGlvbltHTE9CQUxfSU5TVFJVTUVOVEFUSU9OX0tFWV07XG4gIHJldHVybiBmYWxsYmFja0dsb2JhbD8uaGVscGVyO1xufVxuZnVuY3Rpb24gc2V0R2xvYmFsVHJhY2luZ0hlbHBlcihoZWxwZXIpIHtcbiAgY29uc3QgZ2xvYmFsVmFsdWUgPSB7IGhlbHBlciB9O1xuICBnbG9iYWxUaGlzV2l0aFByaXNtYUluc3RydW1lbnRhdGlvbltHTE9CQUxfVkVSU0lPTkVEX0lOU1RSVU1FTlRBVElPTl9LRVldID0gZ2xvYmFsVmFsdWU7XG4gIGdsb2JhbFRoaXNXaXRoUHJpc21hSW5zdHJ1bWVudGF0aW9uW0dMT0JBTF9JTlNUUlVNRU5UQVRJT05fS0VZXSA9IGdsb2JhbFZhbHVlO1xufVxuZnVuY3Rpb24gY2xlYXJHbG9iYWxUcmFjaW5nSGVscGVyKCkge1xuICBkZWxldGUgZ2xvYmFsVGhpc1dpdGhQcmlzbWFJbnN0cnVtZW50YXRpb25bR0xPQkFMX1ZFUlNJT05FRF9JTlNUUlVNRU5UQVRJT05fS0VZXTtcbiAgZGVsZXRlIGdsb2JhbFRoaXNXaXRoUHJpc21hSW5zdHJ1bWVudGF0aW9uW0dMT0JBTF9JTlNUUlVNRU5UQVRJT05fS0VZXTtcbn1cblxuLy8gc3JjL0FjdGl2ZVRyYWNpbmdIZWxwZXIudHNcbnZhciBpbXBvcnRfYXBpID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbnZhciBzaG93QWxsVHJhY2VzID0gcHJvY2Vzcy5lbnYuUFJJU01BX1NIT1dfQUxMX1RSQUNFUyA9PT0gXCJ0cnVlXCI7XG52YXIgbm9uU2FtcGxlZFRyYWNlUGFyZW50ID0gYDAwLTEwLTEwLTAwYDtcbmZ1bmN0aW9uIGVuZ2luZVNwYW5LaW5kVG9PdGVsU3BhbktpbmQoZW5naW5lU3BhbktpbmQpIHtcbiAgc3dpdGNoIChlbmdpbmVTcGFuS2luZCkge1xuICAgIGNhc2UgXCJjbGllbnRcIjpcbiAgICAgIHJldHVybiBpbXBvcnRfYXBpLlNwYW5LaW5kLkNMSUVOVDtcbiAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGltcG9ydF9hcGkuU3BhbktpbmQuSU5URVJOQUw7XG4gIH1cbn1cbnZhciBBY3RpdmVUcmFjaW5nSGVscGVyID0gY2xhc3Mge1xuICB0cmFjZXJQcm92aWRlcjtcbiAgaWdub3JlU3BhblR5cGVzO1xuICBjb25zdHJ1Y3Rvcih7IHRyYWNlclByb3ZpZGVyLCBpZ25vcmVTcGFuVHlwZXMgfSkge1xuICAgIHRoaXMudHJhY2VyUHJvdmlkZXIgPSB0cmFjZXJQcm92aWRlcjtcbiAgICB0aGlzLmlnbm9yZVNwYW5UeXBlcyA9IGlnbm9yZVNwYW5UeXBlcztcbiAgfVxuICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0VHJhY2VQYXJlbnQoY29udGV4dCkge1xuICAgIGNvbnN0IHNwYW4gPSBpbXBvcnRfYXBpLnRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQgPz8gaW1wb3J0X2FwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgICBpZiAoc3Bhbikge1xuICAgICAgcmV0dXJuIGAwMC0ke3NwYW4udHJhY2VJZH0tJHtzcGFuLnNwYW5JZH0tMCR7c3Bhbi50cmFjZUZsYWdzfWA7XG4gICAgfVxuICAgIHJldHVybiBub25TYW1wbGVkVHJhY2VQYXJlbnQ7XG4gIH1cbiAgZGlzcGF0Y2hFbmdpbmVTcGFucyhzcGFucykge1xuICAgIGNvbnN0IHRyYWNlciA9IHRoaXMudHJhY2VyUHJvdmlkZXIuZ2V0VHJhY2VyKFwicHJpc21hXCIpO1xuICAgIGNvbnN0IGxpbmtJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvb3RzID0gc3BhbnMuZmlsdGVyKChzcGFuKSA9PiBzcGFuLnBhcmVudElkID09PSBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMpIHtcbiAgICAgIGRpc3BhdGNoRW5naW5lU3Bhbih0cmFjZXIsIHJvb3QsIHNwYW5zLCBsaW5rSWRzLCB0aGlzLmlnbm9yZVNwYW5UeXBlcyk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGltcG9ydF9hcGkuY29udGV4dC5hY3RpdmUoKTtcbiAgfVxuICBydW5JbkNoaWxkU3BhbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnRlcm5hbCAmJiAhc2hvd0FsbFRyYWNlcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNlciA9IHRoaXMudHJhY2VyUHJvdmlkZXIuZ2V0VHJhY2VyKFwicHJpc21hXCIpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgPz8gdGhpcy5nZXRBY3RpdmVDb250ZXh0KCk7XG4gICAgY29uc3QgbmFtZSA9IGBwcmlzbWE6Y2xpZW50OiR7b3B0aW9ucy5uYW1lfWA7XG4gICAgaWYgKHNob3VsZElnbm9yZVNwYW4obmFtZSwgdGhpcy5pZ25vcmVTcGFuVHlwZXMpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRyYWNlci5zdGFydFNwYW4obmFtZSwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW5kU3BhbihzcGFuLCBjYWxsYmFjayhzcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUsIG9wdGlvbnMsIChzcGFuKSA9PiBlbmRTcGFuKHNwYW4sIGNhbGxiYWNrKHNwYW4sIGNvbnRleHQpKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBkaXNwYXRjaEVuZ2luZVNwYW4odHJhY2VyLCBlbmdpbmVTcGFuLCBhbGxTcGFucywgbGlua0lkcywgaWdub3JlU3BhblR5cGVzKSB7XG4gIGlmIChzaG91bGRJZ25vcmVTcGFuKGVuZ2luZVNwYW4ubmFtZSwgaWdub3JlU3BhblR5cGVzKSkgcmV0dXJuO1xuICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICBhdHRyaWJ1dGVzOiBlbmdpbmVTcGFuLmF0dHJpYnV0ZXMsXG4gICAga2luZDogZW5naW5lU3BhbktpbmRUb090ZWxTcGFuS2luZChlbmdpbmVTcGFuLmtpbmQpLFxuICAgIHN0YXJ0VGltZTogZW5naW5lU3Bhbi5zdGFydFRpbWVcbiAgfTtcbiAgdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihlbmdpbmVTcGFuLm5hbWUsIHNwYW5PcHRpb25zLCAoc3BhbikgPT4ge1xuICAgIGxpbmtJZHMuc2V0KGVuZ2luZVNwYW4uaWQsIHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQpO1xuICAgIGlmIChlbmdpbmVTcGFuLmxpbmtzKSB7XG4gICAgICBzcGFuLmFkZExpbmtzKFxuICAgICAgICBlbmdpbmVTcGFuLmxpbmtzLmZsYXRNYXAoKGxpbmspID0+IHtcbiAgICAgICAgICBjb25zdCBsaW5rZWRJZCA9IGxpbmtJZHMuZ2V0KGxpbmspO1xuICAgICAgICAgIGlmICghbGlua2VkSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgc3BhbklkOiBsaW5rZWRJZCxcbiAgICAgICAgICAgICAgdHJhY2VJZDogc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsXG4gICAgICAgICAgICAgIHRyYWNlRmxhZ3M6IHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUZsYWdzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gYWxsU3BhbnMuZmlsdGVyKChzKSA9PiBzLnBhcmVudElkID09PSBlbmdpbmVTcGFuLmlkKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBkaXNwYXRjaEVuZ2luZVNwYW4odHJhY2VyLCBjaGlsZCwgYWxsU3BhbnMsIGxpbmtJZHMsIGlnbm9yZVNwYW5UeXBlcyk7XG4gICAgfVxuICAgIHNwYW4uZW5kKGVuZ2luZVNwYW4uZW5kVGltZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5kU3BhbihzcGFuLCByZXN1bHQpIHtcbiAgaWYgKGlzUHJvbWlzZUxpa2UocmVzdWx0KSkge1xuICAgIHJldHVybiByZXN1bHQudGhlbihcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzcGFuLmVuZCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbXCJ0aGVuXCJdID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVTcGFuKHNwYW5OYW1lLCBpZ25vcmVTcGFuVHlwZXMpIHtcbiAgcmV0dXJuIGlnbm9yZVNwYW5UeXBlcy5zb21lKFxuICAgIChwYXR0ZXJuKSA9PiB0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiA/IHBhdHRlcm4gPT09IHNwYW5OYW1lIDogcGF0dGVybi50ZXN0KHNwYW5OYW1lKVxuICApO1xufVxuXG4vLyBwYWNrYWdlLmpzb25cbnZhciBwYWNrYWdlX2RlZmF1bHQyID0ge1xuICBuYW1lOiBcIkBwcmlzbWEvaW5zdHJ1bWVudGF0aW9uXCIsXG4gIHZlcnNpb246IFwiNy4yLjBcIixcbiAgZGVzY3JpcHRpb246IFwiT3BlblRlbGVtZXRyeSBjb21wbGlhbnQgaW5zdHJ1bWVudGF0aW9uIGZvciBQcmlzbWEgQ2xpZW50XCIsXG4gIG1haW46IFwiZGlzdC9pbmRleC5qc1wiLFxuICBtb2R1bGU6IFwiZGlzdC9pbmRleC5tanNcIixcbiAgdHlwZXM6IFwiZGlzdC9pbmRleC5kLnRzXCIsXG4gIGV4cG9ydHM6IHtcbiAgICBcIi5cIjoge1xuICAgICAgcmVxdWlyZToge1xuICAgICAgICB0eXBlczogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICAgICAgICBkZWZhdWx0OiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgICB9LFxuICAgICAgaW1wb3J0OiB7XG4gICAgICAgIHR5cGVzOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIGRlZmF1bHQ6IFwiLi9kaXN0L2luZGV4Lm1qc1wiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBsaWNlbnNlOiBcIkFwYWNoZS0yLjBcIixcbiAgaG9tZXBhZ2U6IFwiaHR0cHM6Ly93d3cucHJpc21hLmlvXCIsXG4gIHJlcG9zaXRvcnk6IHtcbiAgICB0eXBlOiBcImdpdFwiLFxuICAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS5naXRcIixcbiAgICBkaXJlY3Rvcnk6IFwicGFja2FnZXMvaW5zdHJ1bWVudGF0aW9uXCJcbiAgfSxcbiAgYnVnczogXCJodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNcIixcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjogXCIxLjkuMFwiLFxuICAgIFwiQHByaXNtYS9pbnN0cnVtZW50YXRpb24tY29udHJhY3RcIjogXCJ3b3Jrc3BhY2U6KlwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJ+MjAuMTkuMjRcIixcbiAgICB0eXBlc2NyaXB0OiBcIjUuNC41XCJcbiAgfSxcbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIjogXCJeMC4yMDcuMFwiXG4gIH0sXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHtcbiAgICBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiOiBcIl4xLjhcIlxuICB9LFxuICBmaWxlczogW1xuICAgIFwiZGlzdFwiXG4gIF0sXG4gIGtleXdvcmRzOiBbXG4gICAgXCJwcmlzbWFcIixcbiAgICBcImluc3RydW1lbnRhdGlvblwiLFxuICAgIFwib3BlbnRlbGVtZXRyeVwiLFxuICAgIFwib3RlbFwiXG4gIF0sXG4gIHNjcmlwdHM6IHtcbiAgICBkZXY6IFwiREVWPXRydWUgdHN4IGhlbHBlcnMvYnVpbGQudHNcIixcbiAgICBidWlsZDogXCJ0c3ggaGVscGVycy9idWlsZC50c1wiLFxuICAgIHByZXB1Ymxpc2hPbmx5OiBcInBucG0gcnVuIGJ1aWxkXCIsXG4gICAgdGVzdDogXCJ2aXRlc3QgcnVuXCJcbiAgfSxcbiAgc2lkZUVmZmVjdHM6IGZhbHNlXG59O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVkVSU0lPTiA9IHBhY2thZ2VfZGVmYXVsdDIudmVyc2lvbjtcbnZhciBOQU1FID0gcGFja2FnZV9kZWZhdWx0Mi5uYW1lO1xudmFyIE1PRFVMRV9OQU1FID0gXCJAcHJpc21hL2NsaWVudFwiO1xuXG4vLyBzcmMvUHJpc21hSW5zdHJ1bWVudGF0aW9uLnRzXG52YXIgUHJpc21hSW5zdHJ1bWVudGF0aW9uID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICB0cmFjZXJQcm92aWRlcjtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcihOQU1FLCBWRVJTSU9OLCBjb25maWcpO1xuICB9XG4gIHNldFRyYWNlclByb3ZpZGVyKHRyYWNlclByb3ZpZGVyKSB7XG4gICAgdGhpcy50cmFjZXJQcm92aWRlciA9IHRyYWNlclByb3ZpZGVyO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgbW9kdWxlMiA9IG5ldyBpbXBvcnRfaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKE1PRFVMRV9OQU1FLCBbVkVSU0lPTl0pO1xuICAgIHJldHVybiBbbW9kdWxlMl07XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICBzZXRHbG9iYWxUcmFjaW5nSGVscGVyKFxuICAgICAgbmV3IEFjdGl2ZVRyYWNpbmdIZWxwZXIoe1xuICAgICAgICB0cmFjZXJQcm92aWRlcjogdGhpcy50cmFjZXJQcm92aWRlciA/PyBpbXBvcnRfYXBpMi50cmFjZS5nZXRUcmFjZXJQcm92aWRlcigpLFxuICAgICAgICBpZ25vcmVTcGFuVHlwZXM6IGNvbmZpZy5pZ25vcmVTcGFuVHlwZXMgPz8gW11cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGNsZWFyR2xvYmFsVHJhY2luZ0hlbHBlcigpO1xuICB9XG4gIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gZ2V0R2xvYmFsVHJhY2luZ0hlbHBlcigpICE9PSB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGltcG9ydF9pbnN0cnVtZW50YXRpb24yID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBQcmlzbWFJbnN0cnVtZW50YXRpb24sXG4gIHJlZ2lzdGVySW5zdHJ1bWVudGF0aW9uc1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@prisma+instrumentation@7.2.0_@opentelemetry+api@1.9.0/node_modules/@prisma/instrumentation/dist/index.js\n");

/***/ })

};
;