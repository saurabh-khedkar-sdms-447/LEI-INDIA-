"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\nvar undici_1 = __webpack_require__(/*! ./undici */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\");\nObject.defineProperty(exports, \"UndiciInstrumentation\", ({ enumerable: true, get: function () { return undici_1.UndiciInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLXVuZGljaUAwLjIxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tdW5kaWNpL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHlMQUFVO0FBQ2pDLHlEQUF3RCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUMxSSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlaWluZGlhcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMjEuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL2luZGV4LmpzPzE4ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmRpY2lJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG52YXIgdW5kaWNpXzEgPSByZXF1aXJlKFwiLi91bmRpY2lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmRpY2lJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGljaV8xLlVuZGljaUluc3RydW1lbnRhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js ***!
  \*************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst diagch = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.211.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@2.5.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.39.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\");\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass UndiciInstrumentation extends instrumentation_1.InstrumentationBase {\n    _recordFromReq = new WeakMap();\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    // No need to instrument files/modules\n    init() {\n        return undefined;\n    }\n    disable() {\n        super.disable();\n        this._channelSubs.forEach(sub => sub.unsubscribe());\n        this._channelSubs.length = 0;\n    }\n    enable() {\n        // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n        // If constructed with `{enabled: false}`, this `.enable()` is still called,\n        // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n        //\n        // For now, this class will setup for instrumenting if `.enable()` is\n        // called, but use `this.getConfig().enabled` to determine if\n        // instrumentation should be generated. This covers the more likely common\n        // case of config being given a construction time, rather than later via\n        // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n        super.enable();\n        // This method is called by the super-class constructor before ours is\n        // called. So we need to ensure the property is initalized.\n        this._channelSubs = this._channelSubs || [];\n        // Avoid to duplicate subscriptions\n        if (this._channelSubs.length > 0) {\n            return;\n        }\n        this.subscribeToChannel('undici:request:create', this.onRequestCreated.bind(this));\n        this.subscribeToChannel('undici:client:sendHeaders', this.onRequestHeaders.bind(this));\n        this.subscribeToChannel('undici:request:headers', this.onResponseHeaders.bind(this));\n        this.subscribeToChannel('undici:request:trailers', this.onDone.bind(this));\n        this.subscribeToChannel('undici:request:error', this.onError.bind(this));\n    }\n    _updateMetricInstruments() {\n        this._httpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        // `diagnostics_channel` had a ref counting bug until v18.19.0.\n        // https://github.com/nodejs/node/pull/47520\n        const [major, minor] = process.version\n            .replace('v', '')\n            .split('.')\n            .map(n => Number(n));\n        const useNewSubscribe = major > 18 || (major === 18 && minor >= 19);\n        let unsubscribe;\n        if (useNewSubscribe) {\n            diagch.subscribe?.(diagnosticChannel, onMessage);\n            unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n        }\n        else {\n            const channel = diagch.channel(diagnosticChannel);\n            channel.subscribe(onMessage);\n            unsubscribe = () => channel.unsubscribe(onMessage);\n        }\n        this._channelSubs.push({\n            name: diagnosticChannel,\n            unsubscribe,\n        });\n    }\n    parseRequestHeaders(request) {\n        const result = new Map();\n        if (Array.isArray(request.headers)) {\n            // headers are an array [k1, v2, k2, v2] (undici v6+)\n            // values could be string or a string[] for multiple values\n            for (let i = 0; i < request.headers.length; i += 2) {\n                const key = request.headers[i];\n                const value = request.headers[i + 1];\n                // Key should always be a string, but the types don't know that, and let's be safe\n                if (typeof key === 'string') {\n                    result.set(key.toLowerCase(), value);\n                }\n            }\n        }\n        else if (typeof request.headers === 'string') {\n            // headers are a raw string (undici v5)\n            // headers could be repeated in several lines for multiple values\n            const headers = request.headers.split('\\r\\n');\n            for (const line of headers) {\n                if (!line) {\n                    continue;\n                }\n                const colonIndex = line.indexOf(':');\n                if (colonIndex === -1) {\n                    // Invalid header? Probably this can't happen, but again let's be safe.\n                    continue;\n                }\n                const key = line.substring(0, colonIndex).toLowerCase();\n                const value = line.substring(colonIndex + 1).trim();\n                const allValues = result.get(key);\n                if (allValues && Array.isArray(allValues)) {\n                    allValues.push(value);\n                }\n                else if (allValues) {\n                    result.set(key, [allValues, value]);\n                }\n                else {\n                    result.set(key, value);\n                }\n            }\n        }\n        return result;\n    }\n    // This is the 1st message we receive for each request (fired after request creation). Here we will\n    // create the span and populate some atttributes, then link the span to the request for further\n    // span processing\n    onRequestCreated({ request }) {\n        // Ignore if:\n        // - instrumentation is disabled\n        // - ignored by config\n        // - method is 'CONNECT'\n        const config = this.getConfig();\n        const enabled = config.enabled !== false;\n        const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => !enabled ||\n            request.method === 'CONNECT' ||\n            config.ignoreRequestHook?.(request), e => e && this._diag.error('caught ignoreRequestHook error: ', e), true);\n        if (shouldIgnoreReq) {\n            return;\n        }\n        const startTime = (0, core_1.hrTime)();\n        let requestUrl;\n        try {\n            requestUrl = new url_1.URL(request.path, request.origin);\n        }\n        catch (err) {\n            this._diag.warn('could not determine url.full:', err);\n            // Skip instrumenting this request.\n            return;\n        }\n        const urlScheme = requestUrl.protocol.replace(':', '');\n        const requestMethod = this.getRequestMethod(request.method);\n        const attributes = {\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: requestMethod,\n            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL]: request.method,\n            [semantic_conventions_1.ATTR_URL_FULL]: requestUrl.toString(),\n            [semantic_conventions_1.ATTR_URL_PATH]: requestUrl.pathname,\n            [semantic_conventions_1.ATTR_URL_QUERY]: requestUrl.search,\n            [semantic_conventions_1.ATTR_URL_SCHEME]: urlScheme,\n        };\n        const schemePorts = { https: '443', http: '80' };\n        const serverAddress = requestUrl.hostname;\n        const serverPort = requestUrl.port || schemePorts[urlScheme];\n        attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS] = serverAddress;\n        if (serverPort && !isNaN(Number(serverPort))) {\n            attributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverPort);\n        }\n        // Get user agent from headers\n        const headersMap = this.parseRequestHeaders(request);\n        const userAgentValues = headersMap.get('user-agent');\n        if (userAgentValues) {\n            // NOTE: having multiple user agents is not expected so\n            // we're going to take last one like `curl` does\n            // ref: https://curl.se/docs/manpage.html#-A\n            const userAgent = Array.isArray(userAgentValues)\n                ? userAgentValues[userAgentValues.length - 1]\n                : userAgentValues;\n            attributes[semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL] = userAgent;\n        }\n        // Get attributes from the hook if present\n        const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.startSpanHook?.(request), e => e && this._diag.error('caught startSpanHook error: ', e), true);\n        if (hookAttributes) {\n            Object.entries(hookAttributes).forEach(([key, val]) => {\n                attributes[key] = val;\n            });\n        }\n        // Check if parent span is required via config and:\n        // - if a parent is required but not present, we use a `NoopSpan` to still\n        //   propagate context without recording it.\n        // - create a span otherwise\n        const activeCtx = api_1.context.active();\n        const currentSpan = api_1.trace.getSpan(activeCtx);\n        let span;\n        if (config.requireParentforSpans &&\n            (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else {\n            span = this.tracer.startSpan(requestMethod === '_OTHER' ? 'HTTP' : requestMethod, {\n                kind: api_1.SpanKind.CLIENT,\n                attributes: attributes,\n            }, activeCtx);\n        }\n        // Execute the request hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.requestHook?.(span, request), e => e && this._diag.error('caught requestHook error: ', e), true);\n        // Context propagation goes last so no hook can tamper\n        // the propagation headers\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        const headerEntries = Object.entries(addedHeaders);\n        for (let i = 0; i < headerEntries.length; i++) {\n            const [k, v] = headerEntries[i];\n            if (typeof request.addHeader === 'function') {\n                request.addHeader(k, v);\n            }\n            else if (typeof request.headers === 'string') {\n                request.headers += `${k}: ${v}\\r\\n`;\n            }\n            else if (Array.isArray(request.headers)) {\n                // undici@6.11.0 accidentally, briefly removed `request.addHeader()`.\n                request.headers.push(k, v);\n            }\n        }\n        this._recordFromReq.set(request, { span, attributes, startTime });\n    }\n    // This is the 2nd message we receive for each request. It is fired when connection with\n    // the remote is established and about to send the first byte. Here we do have info about the\n    // remote address and port so we can populate some `network.*` attributes into the span\n    onRequestHeaders({ request, socket }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const config = this.getConfig();\n        const { span } = record;\n        const { remoteAddress, remotePort } = socket;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: remoteAddress,\n            [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: remotePort,\n        };\n        // After hooks have been processed (which may modify request headers)\n        // we can collect the headers based on the configuration\n        if (config.headersToSpanAttributes?.requestHeaders) {\n            const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map(n => n.toLowerCase()));\n            const headersMap = this.parseRequestHeaders(request);\n            for (const [name, value] of headersMap.entries()) {\n                if (headersToAttribs.has(name)) {\n                    const attrValue = Array.isArray(value) ? value.join(', ') : value;\n                    spanAttributes[`http.request.header.${name}`] = attrValue;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n    }\n    // This is the 3rd message we get for each request and it's fired when the server\n    // headers are received, body may not be accessible yet.\n    // From the response headers we can set the status and content length\n    onResponseHeaders({ request, response, }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes } = record;\n        const spanAttributes = {\n            [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: response.statusCode,\n        };\n        const config = this.getConfig();\n        // Execute the response hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.responseHook?.(span, { request, response }), e => e && this._diag.error('caught responseHook error: ', e), true);\n        const headersToAttribs = new Set();\n        if (config.headersToSpanAttributes?.responseHeaders) {\n            config.headersToSpanAttributes?.responseHeaders.forEach(name => headersToAttribs.add(name.toLowerCase()));\n        }\n        for (let idx = 0; idx < response.headers.length; idx = idx + 2) {\n            const name = response.headers[idx].toString().toLowerCase();\n            const value = response.headers[idx + 1];\n            if (headersToAttribs.has(name)) {\n                spanAttributes[`http.response.header.${name}`] = value.toString();\n            }\n            if (name === 'content-length') {\n                const contentLength = Number(value.toString());\n                if (!isNaN(contentLength)) {\n                    spanAttributes['http.response.header.content-length'] = contentLength;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n        span.setStatus({\n            code: response.statusCode >= 400\n                ? api_1.SpanStatusCode.ERROR\n                : api_1.SpanStatusCode.UNSET,\n        });\n        record.attributes = Object.assign(attributes, spanAttributes);\n    }\n    // This is the last event we receive if the request went without any errors\n    onDone({ request }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // End the span\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics\n        this.recordRequestDuration(attributes, startTime);\n    }\n    // This is the event we get when something is wrong in the request like\n    // - invalid options when calling `fetch` global API or any undici method for request\n    // - connectivity errors such as unreachable host\n    // - requests aborted through an `AbortController.signal`\n    // NOTE: server errors are considered valid responses and it's the lib consumer\n    // who should deal with that.\n    onError({ request, error }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // NOTE: in `undici@6.3.0` when request aborted the error type changes from\n        // a custom error (`RequestAbortedError`) to a built-in `DOMException` carrying\n        // some differences:\n        // - `code` is from DOMEXception (ABORT_ERR: 20)\n        // - `message` changes\n        // - stacktrace is smaller and contains node internal frames\n        span.recordException(error);\n        span.setStatus({\n            code: api_1.SpanStatusCode.ERROR,\n            message: error.message,\n        });\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics (with the error)\n        attributes[semantic_conventions_1.ATTR_ERROR_TYPE] = error.message;\n        this.recordRequestDuration(attributes, startTime);\n    }\n    recordRequestDuration(attributes, startTime) {\n        // Time to record metrics\n        const metricsAttributes = {};\n        // Get the attribs already in span attributes\n        const keysToCopy = [\n            semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE,\n            semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD,\n            semantic_conventions_1.ATTR_SERVER_ADDRESS,\n            semantic_conventions_1.ATTR_SERVER_PORT,\n            semantic_conventions_1.ATTR_URL_SCHEME,\n            semantic_conventions_1.ATTR_ERROR_TYPE,\n        ];\n        keysToCopy.forEach(key => {\n            if (key in attributes) {\n                metricsAttributes[key] = attributes[key];\n            }\n        });\n        // Take the duration and record it\n        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;\n        this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);\n    }\n    getRequestMethod(original) {\n        const knownMethods = {\n            CONNECT: true,\n            OPTIONS: true,\n            HEAD: true,\n            GET: true,\n            POST: true,\n            PUT: true,\n            PATCH: true,\n            DELETE: true,\n            TRACE: true,\n        };\n        if (original.toUpperCase() in knownMethods) {\n            return original.toUpperCase();\n        }\n        return '_OTHER';\n    }\n}\nexports.UndiciInstrumentation = UndiciInstrumentation;\n//# sourceMappingURL=undici.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLXVuZGljaUAwLjIxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tdW5kaWNpL2J1aWxkL3NyYy91bmRpY2kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBcUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLGlNQUFnQztBQUNsRSxjQUFjLG1CQUFPLENBQUMsa0lBQW9CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw4SkFBcUI7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsc0xBQXFDO0FBQzVFO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMkxBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxJQUFJLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZCQUE2QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlaWluZGlhcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMjEuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3VuZGljaS5qcz83YjJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmRpY2lJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZGlhZ2NoID0gcmVxdWlyZShcImRpYWdub3N0aWNzX2NoYW5uZWxcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG4vLyBBIGNvbWJpbmF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2FwbS1hZ2VudC1ub2RlanMgYW5kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2FkZ2V0LWluYy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbnMvYmxvYi9tYWluL3BhY2thZ2VzL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9zcmMvaW5kZXgudHNcbmNsYXNzIFVuZGljaUluc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIF9yZWNvcmRGcm9tUmVxID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih2ZXJzaW9uXzEuUEFDS0FHRV9OQU1FLCB2ZXJzaW9uXzEuUEFDS0FHRV9WRVJTSU9OLCBjb25maWcpO1xuICAgIH1cbiAgICAvLyBObyBuZWVkIHRvIGluc3RydW1lbnQgZmlsZXMvbW9kdWxlc1xuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5fY2hhbm5lbFN1YnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLl9jaGFubmVsU3Vicy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIC8vIFwiZW5hYmxlZFwiIGhhbmRsaW5nIGlzIGN1cnJlbnRseSBhIGJpdCBtZXNzeSB3aXRoIEluc3RydW1lbnRhdGlvbkJhc2UuXG4gICAgICAgIC8vIElmIGNvbnN0cnVjdGVkIHdpdGggYHtlbmFibGVkOiBmYWxzZX1gLCB0aGlzIGAuZW5hYmxlKClgIGlzIHN0aWxsIGNhbGxlZCxcbiAgICAgICAgLy8gYW5kIGB0aGlzLmdldENvbmZpZygpLmVuYWJsZWQgIT09IHRoaXMuaXNFbmFibGVkKClgLCBjcmVhdGluZyBjb25mdXNpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBub3csIHRoaXMgY2xhc3Mgd2lsbCBzZXR1cCBmb3IgaW5zdHJ1bWVudGluZyBpZiBgLmVuYWJsZSgpYCBpc1xuICAgICAgICAvLyBjYWxsZWQsIGJ1dCB1c2UgYHRoaXMuZ2V0Q29uZmlnKCkuZW5hYmxlZGAgdG8gZGV0ZXJtaW5lIGlmXG4gICAgICAgIC8vIGluc3RydW1lbnRhdGlvbiBzaG91bGQgYmUgZ2VuZXJhdGVkLiBUaGlzIGNvdmVycyB0aGUgbW9yZSBsaWtlbHkgY29tbW9uXG4gICAgICAgIC8vIGNhc2Ugb2YgY29uZmlnIGJlaW5nIGdpdmVuIGEgY29uc3RydWN0aW9uIHRpbWUsIHJhdGhlciB0aGFuIGxhdGVyIHZpYVxuICAgICAgICAvLyBgaW5zdGFuY2UuZW5hYmxlKClgLCBgLmRpc2FibGUoKWAsIG9yIGAuc2V0Q29uZmlnKClgIGNhbGxzLlxuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBzdXBlci1jbGFzcyBjb25zdHJ1Y3RvciBiZWZvcmUgb3VycyBpc1xuICAgICAgICAvLyBjYWxsZWQuIFNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBwcm9wZXJ0eSBpcyBpbml0YWxpemVkLlxuICAgICAgICB0aGlzLl9jaGFubmVsU3VicyA9IHRoaXMuX2NoYW5uZWxTdWJzIHx8IFtdO1xuICAgICAgICAvLyBBdm9pZCB0byBkdXBsaWNhdGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICBpZiAodGhpcy5fY2hhbm5lbFN1YnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpjcmVhdGUnLCB0aGlzLm9uUmVxdWVzdENyZWF0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJywgdGhpcy5vblJlcXVlc3RIZWFkZXJzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycsIHRoaXMub25SZXNwb25zZUhlYWRlcnMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycsIHRoaXMub25Eb25lLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIF91cGRhdGVNZXRyaWNJbnN0cnVtZW50cygpIHtcbiAgICAgICAgdGhpcy5faHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtYW50aWNfY29udmVudGlvbnNfMS5NRVRSSUNfSFRUUF9DTElFTlRfUkVRVUVTVF9EVVJBVElPTiwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2Ygb3V0Ym91bmQgSFRUUCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ3MnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICAgICAgYWR2aWNlOiB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsXG4gICAgICAgICAgICAgICAgICAgIDcuNSwgMTAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0NoYW5uZWwoZGlhZ25vc3RpY0NoYW5uZWwsIG9uTWVzc2FnZSkge1xuICAgICAgICAvLyBgZGlhZ25vc3RpY3NfY2hhbm5lbGAgaGFkIGEgcmVmIGNvdW50aW5nIGJ1ZyB1bnRpbCB2MTguMTkuMC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDc1MjBcbiAgICAgICAgY29uc3QgW21ham9yLCBtaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25cbiAgICAgICAgICAgIC5yZXBsYWNlKCd2JywgJycpXG4gICAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgICAgLm1hcChuID0+IE51bWJlcihuKSk7XG4gICAgICAgIGNvbnN0IHVzZU5ld1N1YnNjcmliZSA9IG1ham9yID4gMTggfHwgKG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAxOSk7XG4gICAgICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICAgICAgaWYgKHVzZU5ld1N1YnNjcmliZSkge1xuICAgICAgICAgICAgZGlhZ2NoLnN1YnNjcmliZT8uKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBkaWFnY2gudW5zdWJzY3JpYmU/LihkaWFnbm9zdGljQ2hhbm5lbCwgb25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBkaWFnY2guY2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCk7XG4gICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZShvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbm5lbFN1YnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkaWFnbm9zdGljQ2hhbm5lbCxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdC5oZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gaGVhZGVycyBhcmUgYW4gYXJyYXkgW2sxLCB2MiwgazIsIHYyXSAodW5kaWNpIHY2KylcbiAgICAgICAgICAgIC8vIHZhbHVlcyBjb3VsZCBiZSBzdHJpbmcgb3IgYSBzdHJpbmdbXSBmb3IgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3QuaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlcXVlc3QuaGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlcXVlc3QuaGVhZGVyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgLy8gS2V5IHNob3VsZCBhbHdheXMgYmUgYSBzdHJpbmcsIGJ1dCB0aGUgdHlwZXMgZG9uJ3Qga25vdyB0aGF0LCBhbmQgbGV0J3MgYmUgc2FmZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXJzIGFyZSBhIHJhdyBzdHJpbmcgKHVuZGljaSB2NSlcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgY291bGQgYmUgcmVwZWF0ZWQgaW4gc2V2ZXJhbCBsaW5lcyBmb3IgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgaGVhZGVyPyBQcm9iYWJseSB0aGlzIGNhbid0IGhhcHBlbiwgYnV0IGFnYWluIGxldCdzIGJlIHNhZmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBsaW5lLnN1YnN0cmluZygwLCBjb2xvbkluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxWYWx1ZXMgPSByZXN1bHQuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFZhbHVlcyAmJiBBcnJheS5pc0FycmF5KGFsbFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIFthbGxWYWx1ZXMsIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSAxc3QgbWVzc2FnZSB3ZSByZWNlaXZlIGZvciBlYWNoIHJlcXVlc3QgKGZpcmVkIGFmdGVyIHJlcXVlc3QgY3JlYXRpb24pLiBIZXJlIHdlIHdpbGxcbiAgICAvLyBjcmVhdGUgdGhlIHNwYW4gYW5kIHBvcHVsYXRlIHNvbWUgYXR0dHJpYnV0ZXMsIHRoZW4gbGluayB0aGUgc3BhbiB0byB0aGUgcmVxdWVzdCBmb3IgZnVydGhlclxuICAgIC8vIHNwYW4gcHJvY2Vzc2luZ1xuICAgIG9uUmVxdWVzdENyZWF0ZWQoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgLy8gSWdub3JlIGlmOlxuICAgICAgICAvLyAtIGluc3RydW1lbnRhdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgICAvLyAtIGlnbm9yZWQgYnkgY29uZmlnXG4gICAgICAgIC8vIC0gbWV0aG9kIGlzICdDT05ORUNUJ1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBjb25zdCBlbmFibGVkID0gY29uZmlnLmVuYWJsZWQgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBzaG91bGRJZ25vcmVSZXEgPSAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gIWVuYWJsZWQgfHxcbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vaz8uKHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IGlnbm9yZVJlcXVlc3RIb29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVSZXEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgbGV0IHJlcXVlc3RVcmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gbmV3IHVybF8xLlVSTChyZXF1ZXN0LnBhdGgsIHJlcXVlc3Qub3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLndhcm4oJ2NvdWxkIG5vdCBkZXRlcm1pbmUgdXJsLmZ1bGw6JywgZXJyKTtcbiAgICAgICAgICAgIC8vIFNraXAgaW5zdHJ1bWVudGluZyB0aGlzIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsU2NoZW1lID0gcmVxdWVzdFVybC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpO1xuICAgICAgICBjb25zdCByZXF1ZXN0TWV0aG9kID0gdGhpcy5nZXRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUxdOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX0ZVTExdOiByZXF1ZXN0VXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9QQVRIXTogcmVxdWVzdFVybC5wYXRobmFtZSxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1FVRVJZXTogcmVxdWVzdFVybC5zZWFyY2gsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUVdOiB1cmxTY2hlbWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNjaGVtZVBvcnRzID0geyBodHRwczogJzQ0MycsIGh0dHA6ICc4MCcgfTtcbiAgICAgICAgY29uc3Qgc2VydmVyQWRkcmVzcyA9IHJlcXVlc3RVcmwuaG9zdG5hbWU7XG4gICAgICAgIGNvbnN0IHNlcnZlclBvcnQgPSByZXF1ZXN0VXJsLnBvcnQgfHwgc2NoZW1lUG9ydHNbdXJsU2NoZW1lXTtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdID0gc2VydmVyQWRkcmVzcztcbiAgICAgICAgaWYgKHNlcnZlclBvcnQgJiYgIWlzTmFOKE51bWJlcihzZXJ2ZXJQb3J0KSkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXSA9IE51bWJlcihzZXJ2ZXJQb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdXNlciBhZ2VudCBmcm9tIGhlYWRlcnNcbiAgICAgICAgY29uc3QgaGVhZGVyc01hcCA9IHRoaXMucGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXNlckFnZW50VmFsdWVzID0gaGVhZGVyc01hcC5nZXQoJ3VzZXItYWdlbnQnKTtcbiAgICAgICAgaWYgKHVzZXJBZ2VudFZhbHVlcykge1xuICAgICAgICAgICAgLy8gTk9URTogaGF2aW5nIG11bHRpcGxlIHVzZXIgYWdlbnRzIGlzIG5vdCBleHBlY3RlZCBzb1xuICAgICAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gdGFrZSBsYXN0IG9uZSBsaWtlIGBjdXJsYCBkb2VzXG4gICAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vY3VybC5zZS9kb2NzL21hbnBhZ2UuaHRtbCMtQVxuICAgICAgICAgICAgY29uc3QgdXNlckFnZW50ID0gQXJyYXkuaXNBcnJheSh1c2VyQWdlbnRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgPyB1c2VyQWdlbnRWYWx1ZXNbdXNlckFnZW50VmFsdWVzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgOiB1c2VyQWdlbnRWYWx1ZXM7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VU0VSX0FHRU5UX09SSUdJTkFMXSA9IHVzZXJBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYXR0cmlidXRlcyBmcm9tIHRoZSBob29rIGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgaG9va0F0dHJpYnV0ZXMgPSAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uZmlnLnN0YXJ0U3Bhbkhvb2s/LihyZXF1ZXN0KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCBzdGFydFNwYW5Ib29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChob29rQXR0cmlidXRlcykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaG9va0F0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBwYXJlbnQgc3BhbiBpcyByZXF1aXJlZCB2aWEgY29uZmlnIGFuZDpcbiAgICAgICAgLy8gLSBpZiBhIHBhcmVudCBpcyByZXF1aXJlZCBidXQgbm90IHByZXNlbnQsIHdlIHVzZSBhIGBOb29wU3BhbmAgdG8gc3RpbGxcbiAgICAgICAgLy8gICBwcm9wYWdhdGUgY29udGV4dCB3aXRob3V0IHJlY29yZGluZyBpdC5cbiAgICAgICAgLy8gLSBjcmVhdGUgYSBzcGFuIG90aGVyd2lzZVxuICAgICAgICBjb25zdCBhY3RpdmVDdHggPSBhcGlfMS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IGFwaV8xLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICAgICAgbGV0IHNwYW47XG4gICAgICAgIGlmIChjb25maWcucmVxdWlyZVBhcmVudGZvclNwYW5zICYmXG4gICAgICAgICAgICAoIWN1cnJlbnRTcGFuIHx8ICFhcGlfMS50cmFjZS5pc1NwYW5Db250ZXh0VmFsaWQoY3VycmVudFNwYW4uc3BhbkNvbnRleHQoKSkpKSB7XG4gICAgICAgICAgICBzcGFuID0gYXBpXzEudHJhY2Uud3JhcFNwYW5Db250ZXh0KGFwaV8xLklOVkFMSURfU1BBTl9DT05URVhUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4ocmVxdWVzdE1ldGhvZCA9PT0gJ19PVEhFUicgPyAnSFRUUCcgOiByZXF1ZXN0TWV0aG9kLCB7XG4gICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ0xJRU5ULFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9LCBhY3RpdmVDdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIHJlcXVlc3QgaG9vayBpZiBkZWZpbmVkXG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcucmVxdWVzdEhvb2s/LihzcGFuLCByZXF1ZXN0KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCByZXF1ZXN0SG9vayBlcnJvcjogJywgZSksIHRydWUpO1xuICAgICAgICAvLyBDb250ZXh0IHByb3BhZ2F0aW9uIGdvZXMgbGFzdCBzbyBubyBob29rIGNhbiB0YW1wZXJcbiAgICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhlYWRlcnNcbiAgICAgICAgY29uc3QgcmVxdWVzdENvbnRleHQgPSBhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pO1xuICAgICAgICBjb25zdCBhZGRlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBhZGRlZEhlYWRlcnMpO1xuICAgICAgICBjb25zdCBoZWFkZXJFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYWRkZWRIZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBbaywgdl0gPSBoZWFkZXJFbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LmFkZEhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkSGVhZGVyKGssIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMgKz0gYCR7a306ICR7dn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5kaWNpQDYuMTEuMCBhY2NpZGVudGFsbHksIGJyaWVmbHkgcmVtb3ZlZCBgcmVxdWVzdC5hZGRIZWFkZXIoKWAuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnB1c2goaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5zZXQocmVxdWVzdCwgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDJuZCBtZXNzYWdlIHdlIHJlY2VpdmUgZm9yIGVhY2ggcmVxdWVzdC4gSXQgaXMgZmlyZWQgd2hlbiBjb25uZWN0aW9uIHdpdGhcbiAgICAvLyB0aGUgcmVtb3RlIGlzIGVzdGFibGlzaGVkIGFuZCBhYm91dCB0byBzZW5kIHRoZSBmaXJzdCBieXRlLiBIZXJlIHdlIGRvIGhhdmUgaW5mbyBhYm91dCB0aGVcbiAgICAvLyByZW1vdGUgYWRkcmVzcyBhbmQgcG9ydCBzbyB3ZSBjYW4gcG9wdWxhdGUgc29tZSBgbmV0d29yay4qYCBhdHRyaWJ1dGVzIGludG8gdGhlIHNwYW5cbiAgICBvblJlcXVlc3RIZWFkZXJzKHsgcmVxdWVzdCwgc29ja2V0IH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgY29uc3QgeyBzcGFuIH0gPSByZWNvcmQ7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlQWRkcmVzcywgcmVtb3RlUG9ydCB9ID0gc29ja2V0O1xuICAgICAgICBjb25zdCBzcGFuQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX0FERFJFU1NdOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfUE9SVF06IHJlbW90ZVBvcnQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFmdGVyIGhvb2tzIGhhdmUgYmVlbiBwcm9jZXNzZWQgKHdoaWNoIG1heSBtb2RpZnkgcmVxdWVzdCBoZWFkZXJzKVxuICAgICAgICAvLyB3ZSBjYW4gY29sbGVjdCB0aGUgaGVhZGVycyBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvblxuICAgICAgICBpZiAoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5yZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyc1RvQXR0cmlicyA9IG5ldyBTZXQoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzLnJlcXVlc3RIZWFkZXJzLm1hcChuID0+IG4udG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyc01hcCA9IHRoaXMucGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBoZWFkZXJzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzVG9BdHRyaWJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbYGh0dHAucmVxdWVzdC5oZWFkZXIuJHtuYW1lfWBdID0gYXR0clZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoc3BhbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSAzcmQgbWVzc2FnZSB3ZSBnZXQgZm9yIGVhY2ggcmVxdWVzdCBhbmQgaXQncyBmaXJlZCB3aGVuIHRoZSBzZXJ2ZXJcbiAgICAvLyBoZWFkZXJzIGFyZSByZWNlaXZlZCwgYm9keSBtYXkgbm90IGJlIGFjY2Vzc2libGUgeWV0LlxuICAgIC8vIEZyb20gdGhlIHJlc3BvbnNlIGhlYWRlcnMgd2UgY2FuIHNldCB0aGUgc3RhdHVzIGFuZCBjb250ZW50IGxlbmd0aFxuICAgIG9uUmVzcG9uc2VIZWFkZXJzKHsgcmVxdWVzdCwgcmVzcG9uc2UsIH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzIH0gPSByZWNvcmQ7XG4gICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcmVzcG9uc2UgaG9vayBpZiBkZWZpbmVkXG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcucmVzcG9uc2VIb29rPy4oc3BhbiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCByZXNwb25zZUhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVhZGVyc1RvQXR0cmlicyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcz8ucmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LnJlc3BvbnNlSGVhZGVycy5mb3JFYWNoKG5hbWUgPT4gaGVhZGVyc1RvQXR0cmlicy5hZGQobmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVzcG9uc2UuaGVhZGVycy5sZW5ndGg7IGlkeCA9IGlkeCArIDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSByZXNwb25zZS5oZWFkZXJzW2lkeF0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2lkeCArIDFdO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNUb0F0dHJpYnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbYGh0dHAucmVzcG9uc2UuaGVhZGVyLiR7bmFtZX1gXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBOdW1iZXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihjb250ZW50TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1snaHR0cC5yZXNwb25zZS5oZWFkZXIuY29udGVudC1sZW5ndGgnXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhzcGFuQXR0cmlidXRlcyk7XG4gICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwXG4gICAgICAgICAgICAgICAgPyBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUlxuICAgICAgICAgICAgICAgIDogYXBpXzEuU3BhblN0YXR1c0NvZGUuVU5TRVQsXG4gICAgICAgIH0pO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgc3BhbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGV2ZW50IHdlIHJlY2VpdmUgaWYgdGhlIHJlcXVlc3Qgd2VudCB3aXRob3V0IGFueSBlcnJvcnNcbiAgICBvbkRvbmUoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSA9IHJlY29yZDtcbiAgICAgICAgLy8gRW5kIHRoZSBzcGFuXG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3JlY29yZEZyb21SZXEuZGVsZXRlKHJlcXVlc3QpO1xuICAgICAgICAvLyBSZWNvcmQgbWV0cmljc1xuICAgICAgICB0aGlzLnJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSBldmVudCB3ZSBnZXQgd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcgaW4gdGhlIHJlcXVlc3QgbGlrZVxuICAgIC8vIC0gaW52YWxpZCBvcHRpb25zIHdoZW4gY2FsbGluZyBgZmV0Y2hgIGdsb2JhbCBBUEkgb3IgYW55IHVuZGljaSBtZXRob2QgZm9yIHJlcXVlc3RcbiAgICAvLyAtIGNvbm5lY3Rpdml0eSBlcnJvcnMgc3VjaCBhcyB1bnJlYWNoYWJsZSBob3N0XG4gICAgLy8gLSByZXF1ZXN0cyBhYm9ydGVkIHRocm91Z2ggYW4gYEFib3J0Q29udHJvbGxlci5zaWduYWxgXG4gICAgLy8gTk9URTogc2VydmVyIGVycm9ycyBhcmUgY29uc2lkZXJlZCB2YWxpZCByZXNwb25zZXMgYW5kIGl0J3MgdGhlIGxpYiBjb25zdW1lclxuICAgIC8vIHdobyBzaG91bGQgZGVhbCB3aXRoIHRoYXQuXG4gICAgb25FcnJvcih7IHJlcXVlc3QsIGVycm9yIH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSA9IHJlY29yZDtcbiAgICAgICAgLy8gTk9URTogaW4gYHVuZGljaUA2LjMuMGAgd2hlbiByZXF1ZXN0IGFib3J0ZWQgdGhlIGVycm9yIHR5cGUgY2hhbmdlcyBmcm9tXG4gICAgICAgIC8vIGEgY3VzdG9tIGVycm9yIChgUmVxdWVzdEFib3J0ZWRFcnJvcmApIHRvIGEgYnVpbHQtaW4gYERPTUV4Y2VwdGlvbmAgY2FycnlpbmdcbiAgICAgICAgLy8gc29tZSBkaWZmZXJlbmNlczpcbiAgICAgICAgLy8gLSBgY29kZWAgaXMgZnJvbSBET01FWGNlcHRpb24gKEFCT1JUX0VSUjogMjApXG4gICAgICAgIC8vIC0gYG1lc3NhZ2VgIGNoYW5nZXNcbiAgICAgICAgLy8gLSBzdGFja3RyYWNlIGlzIHNtYWxsZXIgYW5kIGNvbnRhaW5zIG5vZGUgaW50ZXJuYWwgZnJhbWVzXG4gICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzICh3aXRoIHRoZSBlcnJvcilcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfRVJST1JfVFlQRV0gPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICB0aGlzLnJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpO1xuICAgIH1cbiAgICByZWNvcmRSZXF1ZXN0RHVyYXRpb24oYXR0cmlidXRlcywgc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIFRpbWUgdG8gcmVjb3JkIG1ldHJpY3NcbiAgICAgICAgY29uc3QgbWV0cmljc0F0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgLy8gR2V0IHRoZSBhdHRyaWJzIGFscmVhZHkgaW4gc3BhbiBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGtleXNUb0NvcHkgPSBbXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERSxcbiAgICAgICAgICAgIHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9ELFxuICAgICAgICAgICAgc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTLFxuICAgICAgICAgICAgc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JULFxuICAgICAgICAgICAgc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUUsXG4gICAgICAgICAgICBzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfRVJST1JfVFlQRSxcbiAgICAgICAgXTtcbiAgICAgICAga2V5c1RvQ29weS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzQXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGFrZSB0aGUgZHVyYXRpb24gYW5kIHJlY29yZCBpdFxuICAgICAgICBjb25zdCBkdXJhdGlvblNlY29uZHMgPSAoMCwgY29yZV8xLmhyVGltZVRvTWlsbGlzZWNvbmRzKSgoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShzdGFydFRpbWUsICgwLCBjb3JlXzEuaHJUaW1lKSgpKSkgLyAxMDAwO1xuICAgICAgICB0aGlzLl9odHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uU2Vjb25kcywgbWV0cmljc0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0TWV0aG9kKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IGtub3duTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIENPTk5FQ1Q6IHRydWUsXG4gICAgICAgICAgICBPUFRJT05TOiB0cnVlLFxuICAgICAgICAgICAgSEVBRDogdHJ1ZSxcbiAgICAgICAgICAgIEdFVDogdHJ1ZSxcbiAgICAgICAgICAgIFBPU1Q6IHRydWUsXG4gICAgICAgICAgICBQVVQ6IHRydWUsXG4gICAgICAgICAgICBQQVRDSDogdHJ1ZSxcbiAgICAgICAgICAgIERFTEVURTogdHJ1ZSxcbiAgICAgICAgICAgIFRSQUNFOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3JpZ2luYWwudG9VcHBlckNhc2UoKSBpbiBrbm93bk1ldGhvZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnX09USEVSJztcbiAgICB9XG59XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IFVuZGljaUluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZGljaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.21.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-undici';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLXVuZGljaUAwLjIxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tdW5kaWNpL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWlpbmRpYXMvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLXVuZGljaUAwLjIxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tdW5kaWNpL2J1aWxkL3NyYy92ZXJzaW9uLmpzPzI0NGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC4yMS4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2knO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.21.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\n");

/***/ })

};
;